# 빅오 표기법(Big-O Notation)

- 여러가지 코드를 서로 비교하여 성능을 평가하는 방법
- 시간 복잡도와 공간 복잡도를 나타내는데 사용 된다.

<br/>

> ## 빅오 표현식 단순화

1. `상수 무시`
   - O(2n) → O(n)
   - O(500) → O(1)
2. `더 작은 조건 무시`
   - O(n + 10) → O(n)
   - O(n² + 5n + 8) →O(n²)

<br/><br/>

> ## 시간 복잡도

알고리즘의 **시간 효율성**(얼마나 빨리 실행되는지)

1. 사칙연산 등 산수 → 상수
2. 변수 할당 → 상수
3. 배열의 인덱스나 객체의 키에 접근 → 상수
4. 루프가 있으면 복잡도는 루프의 길이 x 루프 안에 있는 연산

<br/><br/>

> ## 공간 복잡도

알고리즘의 **공간(메모리) 효율성**(입력이 커질수록 알고리즘이 얼마나 많은 공간을 차지하는지)

1. 대부분 기본 요소(boolean, 숫자, undefined, null) → 상수
2. 문자열 → O(n) (n은 문자열의 길이)
3. 참조형 → O(n) (n은 배열의 경우 길이, 객체의 경우 key의 개수)

<br/><br/>

> ## Recap

- 알고리즘의 성능을 분석하기 위해 Big O 표기법을 사용한다.
- Big O 표기법을 통해 `시간 복잡도`, `공간 복잡도`에 대한 이해를 높일 수 있다.
- 정확도가 아닌, 전체적인 `추세`를 생각한다.
- 시간 복잡도, 공간 복잡도는 하드웨어에 영향을 받지 않는다.

<br/><br/><br/><br/><br/>

# 배열과 객체의 성능 평가

<br/>

> ## 객체

정렬X, 모든 것을 빨리 처리

<br/>

### 객체의 Big O

- 입력 - O(1)
- 제거 - O(1)
- 접근(access) - O(1)
- 탐색(search) - O(n) → 선형 시간, key가 많을수록 걸리는 시간도 늘어난다.

<br/>

### 객체 메서드의 Big O

- Object.keys - O(n)
- Object.values - O(n)
- Object.entries - O(n)
- hasOwnProperty - O(1) ✨

<br/><br/>

> ## 배열

정렬O, 작업에 따라 느릴 수 있음

<br/>

### 배열의 Big O

- 탐색 - O(n)
- 접근 - O(1)
- 입력, 제거 - `어디에 입력, 제거 하는지에 따라 다르다.`
  - 배열 끝에 push, pop → O(1)
  - 배열 시작에 shift, unshift → O(n)
    (배열에 있는 요소마다 인덱스를 새로 배정해야 함)

<br/>

### 배열 메서드의 Big O (암기ㄴㄴ, 이해)

- push, pop - O(1)
- shift, unshift - O(n)
- concat - O(n)
- slice - O(n)
- splice - O(n)
- sort - O(n log n) `→ 정렬은 O(n)보다 크다`
- forEach / map / filter / reduece / etc. - O(n)
