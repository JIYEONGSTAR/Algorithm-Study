# Big O Notation

## 학습 목표 (Objectives)

### Big O 표기법의 정의와 필요성

- **정의** : Big O는 여러가지 코드를 서로 비교하고 성능을 평가하는 척도이자 방법이다.
    - 대략적으로 숫자를 세는 것의 공식적 표현
    - 입력 값이 늘어날 수록 알고리즘 실행 시간이 어떻게 변하는지 설명하는 공식적인 방법 (입력의 크기와 실행시간의 관계)
- ex) 코드를 성능에 따라 분류할 수 있다.
    1. 엄청 좋은 코드!
    2. 꽤 좋은 코드
    3. 그냥 뭐..OK
    4. 에ㅔㅔㅔ…
    5. 엉망인 코드….

- **필요성** :
    1. 코드의 성능을 얘기할 때 정확힌 전문용어를 사용하는 것이 중요하다.
    2. 여러 접근법의 장단점을 얘기할 때 좋다. (꼭 하나의 코드만이 모든 측면에서 성능이 좋을 수 없고 각각의 장단점이 있다.)
    3. 디버그 시 프로그램을 느리게 만드는 비효율적인 코드를 찾을 수 있다.
    4. 면접에 자주 나오는 내용이니까…^^

### Big O 표기법의 단순화

- 상수는 생략 가능하다
    - O(2n) → O(n)
    - O(500) → O(1)
    - O(13n^) → O(n^)
- 작은 연산들도 생략 가능하다
    - O(1000n + 50) → O(n)
    - O(n^ + 5n + 8) → O(n^)

### 시간 복잡도(**Time Complexity**)와 공간 복잡도(**Space Complexity**)

- **시간 복잡도** : 알고리즘의 수행 시간을 평가 (입력이 커질수록 알고리즘의 실행 속도가 어떻게 바뀌는지 분석)

- **코드 시간 재기**

```jsx
function addUpTo(n) {
    let total = 0;
    for(let i = 1; i <= n; i++){
        total += i;
    }
    return total;
}

let t1 = performance.now();
addUpTo(1000000000); // 1~10억까지 덧셈

let t2 = performance.now();
console.log(`Time Elapsed: ${(t2 - t1) / 1000} seconds.`);
// 0.9초
```

```jsx
function addUpTo(n) {
	return n * (n + 1) / 2;
}

let t1 = performance.now();
addUpTo(1000000000); // 1~10억까지 덧셈

let t2 = performance.now();
console.log(`Time Elapsed: ${(t2 - t1) / 1000} seconds.`);
// 0.0001초

```

똑같은 데이터를 다루지만, 두 번째 방법이 훨씬 짧은 시간에 해결했다. → 두 번째 코드가 더 나은 코드!!

- 더 나은 코드의 의미
    - 속도
    - 메모리 사용량
    - 가독성, 짧은 코드

- 시간 측정 비교법의 문제점
    - 측정하는 기계마다 다른 시간이 측정 됨
    - 같은 기계여도 다른 시간이 측정 됨
    - 엄청 빠른 알고리즘의 경우 근소한 차이가 나므로 정확한 측정이 힘듦
    
    → 컴퓨터가 처리해야하는 연산의 개수를 측정하자!
    

- 연산 개수 측정 비교법
    - 첫 번째 방법 : 5n + 2개 (n이 커질수록 연산 증가) vs 두 번째 방법 : 3개 (상수 시간)
    - 5n + 2 같이 정확한 계산보다 O(n)과 같은 전체적 추세를 보는 것이 중요함

```jsx
function countUpAndDown(n) {
  console.log("Going up!");
  for (var i = 0; i < n; i++) { // O(n)
    console.log(i);
  }
  console.log("At the top!\nGoing down...");
  for (var j = n - 1; j >= 0; j--) { // O(n)
    console.log(j);
  }
  console.log("Back down. Bye!");
}

// O(2n) -> 전체적인 추세를 보는 것이므로 결국 O(n)이라 표기함
```

```jsx
function printAllPairs(n) {
  for (var i = 0; i < n; i++) { // O(n)
    for (var j = 0; j < n; j++) { // O(n로그 
      console.log(i, j);
    }
  }
}
```

- 규칙
    1. 기본 산수 연산(+, -, *, /)은 상수 시간이다.
    2. 변수 배정은 상수 시간이다.
    3. 인덱스나 키를 사용해서 배열이나 객체 요소에 접근하는 것은 상수 시간이다.
    4. 루프에서 복잡도 = 루프의 길이 * 루프 안의 연산

- **공간 복잡도** : 알고리즘 수행에 필요한 메모리 양을 평가 (코드가 실행되기 위해 얼마나 추가로 메모리 할당이 필요한 지, 알고리즘 자체가 필요로 하는 공간)

- 규칙
    1. boolean, number, undefined, null 등 대부분의 원시 자료형은 불변 공간(constant space)이다. (어떤 값을 넣어도 같은 공간을 차지)
    2. 문자열은 O(n)의 공간을 차지한다. (길이가 1인 문자열보다 50인 문자열이 더 많은 공간 차지)
    3. 배열, 객체 등 대부분의 reference 타입은 O(n)의 공간을 차지한다.

### 빅 오를 통한 여러가지 알고리즘 평가

### 로그의 정의

- 로그함수는 지수함수의 역함수이다. (나눗셈과 곱셉의 관계처럼 짝을 이룬다.)
- 어떤 수를 나타내기 위해 고정된 밑을 몇 번 곱하여야 하는지를 나타냄
- $log_2(8) = 3$ → $2^3 = 8$
- 이진 로그를 대략적으로 계산하기 위해서 그 숫자가 1보다 작아지기 전에 2로 나눠지는 횟수를 계산한다. (ex. 25 → 2로 4~5번 사이로 나눠지므로 log(25) = 4.64…)
- 로그 복잡도는 O(1) 다음으로 빠른 시간 복잡도를 가진다.

### 배열과 객체의 성능 평가

- **객체** : 순서가 없는 데이터 구조, key-value 쌍으로 저장
- 객체 메서드의 시간 복잡도
    - 추가, 삭제, 접근 등의 작업 - O(1)
    - Object.keys - O(n)
    - Object.values - O(n)
    - Object.entries - O(n)
    - hasOwnProperty - O(1)
- **배열** : 순서가 있는 데이터 구조, 인덱스로 접근
- 배열 메서드의 시간 복잡도
    - 접근 - O(1)
    - 배열 뒤에 요소 추가, 삭제 (push, pop) - O(1)
    - 배열 앞에 요소 추가, 삭제 (shift, unshift) - O(n) (모든 인덱스를 다시 정해주어야 하기 때문)
    - 검색 - O(n)
    - concat, slice, splice - O(n)
    - forEach, map, filter, reduce - O(n)
    - sort - O(n * log n)